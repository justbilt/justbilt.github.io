title: "cocos2d-x 游戏实战经验(二) 新手引导(下)"
id: 495
date: 2013-07-12 13:13:02
tags:
categories: [cocos2d-x,cocos2d-x游戏实战经验]
---

<address>**前言:网上的cocos2d-x教程多为知识点的讲解,但我们学习cocos2d-x的目的是为了什么?为了做出游戏来! cocos2d-x 游戏实战经验 系列文章将分享我在开发游戏过程中遇到的问题及解决方案!**</address><address> </address><address> </address>(接上文)
<!--more-->
下半部分的内容可能会比较枯燥,打理好精神再来吧!



### **二.触摸和按钮响应**



**1.开启触摸 阻止穿透响应 判断落点**

让我们继续看下面的这张图片:

[![QQ截图20130711144242]({{BASE_PATH}}/images/77dcc9c78e40e4cf541eb41c386a1a731d8b2eff.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130711144242.png)



这张图片中应该只有右下角的"冒险"按钮能够响应的到,那么怎么实现呢?这个要用到我之前的文章  [cocos2d-x 游戏实战经验(一) 触摸响应](http://blog.justbilt.com/402/) 中的知识,建议先看下这篇文章,我在这里说下思路:

*   为了让其他区域的按钮响应不到,我们应该提高上层(CClayer)的响应优先级为-128和按钮一样,这样的话如果上层(CClayer)后加入游戏addchild的话,会先收到触摸消息.
*   在收到触摸消息ccTouchBegan时,判断点击的地方是否在黄色矩形区域中,在的话return false 交给下层的按钮去响应,否则return true 阻止消息继续传递.
下面是代码片段:

1).开启触摸
```c++
bool CTeachLayer::init()
{
	if (!CCLayer::init())
	{
		return false;
	}
	setTouchEnabled(true);
	return true;
}
```
2).提升触摸响应优先级为-128
void CTeachLayer::registerWithTouchDispatcher()
{
	//使用-128和CCMenu优先级相同,并且吞掉事件true//
	CCDirector::sharedDirector()->getTouchDispatcher()->addTargetedDelegate(this, -128, true);
	CCLayer::registerWithTouchDispatcher();
}
3).在ccTouchBegan判断触点
```c++
bool CTeachLayer::ccTouchBegan( CCTouch* pTouch, CCEvent* pEvent )
{
        //得到触摸位置
	CCPoint touchPoint = pTouch->getLocation();
        //声明一个右下角100x50的矩形
	CCRect m_obRect=CCRectMake(
		CCDirector::sharedDirector()->getVisibleSize().width-100,
		CCDirector::sharedDirector()->getVisibleSize().height-50,
		100,
		50);
        //判断点是否在矩形中
	if (m_obRect.containsPoint(touchPoint))
	{
		return false;
	}
	return true;
}
```
大功告成,快去试一下吧!



**2.精确命中**

手机上和电脑上的触摸事件的区别在于:电脑上我们是用鼠标点击,而手机上使用手指去摁,触摸的精度的高低不言而喻!让我们来看下面这张图片:

[![QQ截图20130712112739]({{BASE_PATH}}/images/48f5c73509bf938b88bb3589bd6cb0a0bdb696fb.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130712112739.png)



让我们看右上角的X号按钮,在手机上点击它来说应该是很困难的!他的真实尺寸应该是红色矩形的区域(假设:50x50),为了让玩家在引导时,能够很方便的点击到它,我们将实际的可触摸区域设置为蓝色区域(假设:100x100),这样应该很好点到了吧!

这样会有一个新的问题,如果点击到红色和蓝色之间的区域,下面的x按钮时响应不到的,那么怎么办呢?我们需要修改touch的数据(设置为按钮的正中心),然后touch事件将会以新的数据向下传递!这样下面的按钮就能响应到了!

让我们看看代码吧:
```c++
bool CTeachLayer::ccTouchBegan( CCTouch* pTouch, CCEvent* pEvent )
{
	CCPoint touchPoint = pTouch->getLocation();

	if (!CGlobal::s_bTeach)
	{
		return false;
	}
        //假设按钮在(300,200)的位置,那么蓝色矩形如下:
	CCRect m_obRect=CCRectMake(
		250,
		150,
		100,
		100);

	if (m_obRect.containsPoint(touchPoint))
	{
                //得到蓝色矩形的中心点(300,200)
		CCPoint pos=ccp(m_obRect.getMidX(),m_obRect.getMidY());
                //这里要转化为UI坐标系(左上角为0,0点)
		pos=CCDirector::sharedDirector()->convertToUI(pos);
                //设置触摸信息
		pTouch->setTouchInfo(pTouch->getID(),pos.x,pos.y);
		return false;
	}

	return true;
}
```


### **三.逻辑处理及代码组织**

这里我大概说下新手引导的架构,代码肯定贴不出来,太多太乱,说的不对的地方,欢迎大家拍砖吐槽!>_<

1.首先创建了一个CTeachLayer继承自CCLayer,添加到游戏的最上层(UI层之上),记住,要先添加游戏的其层,最后添加CTeachLayer,可以保存全局指针!

2.用一个枚举记下你要引导的所有步骤,在根据枚举值去设置高亮的位置及触摸区域!可以记下当前引导的进度,以方便下次继续引导!

3.游戏逻辑中免不了要判断引导(例:出第3波怪的时候引导玩家使用清屏道具),用全局的指针去设置引导的步骤!

4.引导完成后移除CTeachLayer,游戏开始!





(全文完)

