title: "cocos2d-x 游戏实战经验(二) 新手引导(上)"
id: 454
date: 2013-07-12 09:10:24
tags:
categories: [cocos2d-x游戏实战经验]
---

> 前言:网上的cocos2d-x教程多为知识点的讲解,但我们学习cocos2d-x的目的是为了什么?为了做出游戏来! cocos2d-x 游戏实战经验 系列文章将分享我在开发游戏过程中遇到的问题及解决方案!


<!--more-->
这两天一直在忙新手引导的事情~就如我之前微博上所说的:新手引导是把程序弄乱的最佳途径.好多逻辑得单独判断.(例:买东西是要钱的吧,但新手引导的时候不要,策划们,多为我们着想好不好!)唉...日子还要过,那么我们就一起来征服这个困难吧!



总结了下,新手引导的要点有以下几个:

*   画面的变化.
*   触摸和按钮响应.
*   逻辑处理及代码组织.
下面我们就详细讲述这几个要点:

<!--more-->

### **一.画面的变化.**

对个这个不同的游戏的做法不尽相同,归结起来大概有这么几种:

**1.画面整体变暗**

这个比较简单,cocos2d就有现成接口:
```c++
CCSize visibleSize = CCDirector::sharedDirector()->getVisibleSize();
//第一个参数是颜色ccc4(r,g,b,a) a取值(0~255),越大越不透明 下面两个参数为宽高,不传默认为屏幕大小
CCLayerColor* pLayer=CCLayerColor::create(ccc4(0,0,0,200),visibleSize.width,visibleSize.height);
//CCLayerColor* pLayer=CCLayerColor::create(ccc4(0,0,0,200));
addChild(pLayer,100);
```
效果如下:

![](/images/8bebf85cd9542e0f88c7ee3255a7acc18702246e.png)

然后你可以在这层之上添加精灵,最后的效果可能是这个样子的:

![](/images/59a6b1785d67bebd68e32147cf750bd7c56b07b6.jpg)

注:图片源自网络,如果有版权问题~<del>你丫去死吧! </del>请联系我!



**2.局部高亮**

比较简单的方法是准备几张张局部高亮的图片,随着引导进度变化而切换!优点是可以做的比较精美,缺点是资源量会比较大!另一种方法是在画面整体变暗的基础上抠掉部分区域,还好cocos2d提供了CCClippingNode接口(2.1+版)!

CCClippingNode类比较复杂,但我们只用明白两个东西就好:一个是CCClippingNode的Stencil,一个CCClippingNode的Child,怎么理解呢?请看下图:

![](/images/3bafb7cc8abe1b311d8783143f104a1fcf3fabc3.jpg)



这个东西相信大家都有印象吧,上面的图案(镂空部分)就是 CCClippingNode的Stencil(模板),实体部分就是CCClippingNode的child(底板),是不是很好明白,让我们用代码来实现吧:
```c++
//创建cliper对象
CCClippingNode* pClip=CCClippingNode::create();
addChild(pClip);
//加入灰色的底板
CCLayerColor* pColor=CCLayerColor::create(ccc4(0,0,0,200));
pClip->addChild(pColor);
```
让我来加入模板:
```c++
//创建drawnode对象
CCDrawNode *m_pAA=CCDrawNode::create();
static ccColor4F green = {0, 1, 0, 1};
static CCPoint rect[4]={ccp(-50,50),ccp(50,50),ccp(50,-50),ccp(-50,-50)};
//用上面的数据保存一个100x100的矩形
m_pAA->drawPolygon(rect, 4, green, 0, green);
//设置到屏幕的中心
m_pAA->setPosition(ccp(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y));
//设置为pclip的模板
pClip->setStencil(m_pAA);
```
CCDrawNode是用来绘制几何图形的,drawPolygon使用绘制多边形,参数为顶点数组,顶点数量,边框宽度,和填充颜色!这里要注意一点:千万不要addChild(m_pAA);因为一旦addchild,m_pAA就会被绘制出来,我们是要用它做剪裁!他会在CCClippingNode内部被使用!

我们会看到这样的效果:

![](/images/619417dcbc781b892bbd10f639e0cfcf2f439081.png)



额,貌似和我们想想的不太一样啊,为什么呢?那是因为CCClippingNode有一个选项是是否反向,既显示Stencil呢还是child减去Stencil的部分!默认为显示显示镂空(Stencil)部分(false),因此我们要改变选项:
```c++
//是否反向?
pClip->setInverted(true);
```
效果如下,是不是很棒:

![](/images/66431e65814f0ba6af085db0028b02838cbe5ffc.png)





**3.组合效果(将2的矩形改成圆,再加上图片)**

让我们先看这张图片,是不是很棒?右下角黄色矩形区域是高亮的,在配上图片说明,很不错的效果!

![](/images/77dcc9c78e40e4cf541eb41c386a1a731d8b2eff.png)

让我们来实现类似的效果吧,用到的资源:

![](/images/4b4e61741854ffcb3842717d4fc4acfbff73eb69.png) ![](/images/d7572b333f1016a1262e7a6aba920b2d475ce8d2.png)


```c++
//创建cliper
CCClippingNode* pClip=CCClippingNode::create();
pClip->setInverted(true);
addChild(pClip);
//添加底板
CCLayerColor* pColor=CCLayerColor::create(ccc4(0,0,0,200));
pClip->addChild(pColor);

//绘制圆形区域
static ccColor4F green = {0, 1, 0, 1};//顶点颜色,这里我们没有实质上没有绘制,所以看不出颜色
float fRadius=55.0f;//圆的半径
const int nCount=100;//圆形其实可以看做正多边形,我们这里用正100边型来模拟园
const float coef = 2.0f * (float)M_PI/nCount;//计算每两个相邻顶点与中心的夹角
static CCPoint circle[nCount];//顶点数组
for(unsigned int i = 0;i <nCount; i++) {
	float rads = i*coef;//弧度
	circle[i].x = fRadius * cosf(rads);//对应顶点的x
	circle[i].y = fRadius * sinf(rads);//对应顶点的y
}
CCDrawNode *pStencil=CCDrawNode::create();
pStencil->drawPolygon(circle, nCount, green, 0, green);//绘制这个多边形!

//动起来
pStencil->runAction(CCRepeatForever::create(CCSequence::createWithTwoActions(CCScaleBy::create(0.05f, 0.95f),
	CCScaleTo::create(0.125f, 1))));
pStencil->setPosition(ccp(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y));

//设这模板
pClip->setStencil(pStencil);

//添加圆和手的图片
CCSprite*pCircle=CCSprite::create("circle.png");
pCircle->setPosition(ccp(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y));
pCircle->runAction(CCRepeatForever::create(CCSequence::createWithTwoActions(CCScaleBy::create(0.05f, 0.95f),
	CCScaleTo::create(0.125f, 1))));
addChild(pCircle);

CCSprite* pHand=CCSprite::create("hand.png");
pHand->setAnchorPoint(ccp(0.0f,1.0f));
pHand->setPosition(ccp(pCircle->getContentSize().width/2,pCircle->getContentSize().height/2));
pCircle->addChild(pHand);
```
上面是全部的代码,效果图如下(动态的会更好)没有加圆圈和手之前和之后:

![](/images/d5aa7f74709ae7859b6d1e42ca80acbca896c1cb.png) ![](/images/25a577181967c0f857d26f87c63609add169a784.png)

那么如何改变高亮区域得位置呢?很简单,只用改变pStencil的位置即可!可以考虑记为成员变量在ccTouchesBegan中改变位置,这样就会高亮区域就会跟着你的鼠标走啦!**
**



上篇完,下篇请猛戳下面:

[cocos2d-x 游戏实战经验(二) 新手引导(下)](http://blog.justbilt.com/495/)



