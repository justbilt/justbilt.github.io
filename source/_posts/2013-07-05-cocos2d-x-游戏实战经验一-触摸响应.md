title: "cocos2d-x 游戏实战经验(一) 触摸响应 "
id: 402
date: 2013-07-05 23:46:32
tags: [cocos2d-x]
categories: [cocos2d-x,cocos2d-x游戏实战经验]
---

<address>**前言:网上的cocos2d-x教程多为知识点的讲解,但我们学习cocos2d-x的目的是为了什么?为了做出游戏来! cocos2d-x 游戏实战经验 系列文章将分享我在开发游戏过程中遇到的问题及解决方案!**</address>
<!--more-->
触摸在手机游戏开发中是非常重要的一部分,但cocos2d的触摸解决方案不是很完美,因此我们会遇到很多问题,让我们一起来看看吧!



在这里我主要讲这么几点:

*   开启触摸响应

*   防止touch事件穿透响应
*   模拟弹出式对话框及一些可能遇到的问题的QA


### **一.开启触摸响应（这个好多人都会讲，这里因为下面的内容会用到这里，所以在啰嗦一遍~）**

**1.继承CClayer,重写一下几个函数:**
```c++
	virtual bool init();
	virtual bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	virtual void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	virtual void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	virtual void registerWithTouchDispatcher();
```
**<!--more-->2.函数实现:**
```c++
bool CCBanPenetrateTouchLayer::init()
{
	if (!CCLayer::init())
	{
		return false;
	}
	setTouchEnabled(true);

	return true;
}

bool CCBanPenetrateTouchLayer::ccTouchBegan( CCTouch* pTouch, CCEvent* pEvent )
{
	return false;
}

void CCBanPenetrateTouchLayer::ccTouchMoved( CCTouch* pTouch, CCEvent* pEvent )
{

}

void CCBanPenetrateTouchLayer::ccTouchEnded( CCTouch* pTouch, CCEvent* pEvent )
{

}

void CCBanPenetrateTouchLayer::registerWithTouchDispatcher()
{
	CCDirector::sharedDirector()->getTouchDispatcher()->addTargetedDelegate(this, 0, true);
	CCLayer::registerWithTouchDispatcher();
}
```
说明:

1).addTargetedDelegate()前两个参数分别对应触摸接受对象和优先级,值越小,优先级越高,越先接受触摸消息,最后一个参数是是否吞噬触摸,一旦吞噬后优先级比它低都不会接收到触摸消息.

2.ccTouchBegan的返回值表示触摸事件是否终止传递,返回true则这次触摸事件终止!



### **二.防止touch事件穿透响应**

**1.问题描述:假如游戏中的一个场景(CCScene)中有两层(CClayer),每一层上都会有按钮,如下图所示:**

[![QQ截图20130705190109]({{BASE_PATH}}/images/ec3a2162ccc587fd2fdb472aac2f8a0eb85afa81.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130705190109.png)

注:红色矩形区域为可能穿透区域.



**2.如果我们不做任何处理的话,右上角矩形位置的按钮绝对会被响应到,这显然不是我们想要的!这样我们要做如下处理:**

1).在右上角矩形点击后下层的按钮肯定先响应到触摸消息,因为CCMenu的触摸优先级为-128,几乎是游戏中最高的,我们要做的是提高上层(CCLaye)的触摸优先级:
```c++
void CCBanPenetrateTouchLayer::registerWithTouchDispatcher()
{
	//使用-128和CCMenu优先级相同
	CCDirector::sharedDirector()->getTouchDispatcher()->addTargetedDelegate(this, -128, true);
	CCLayer::registerWithTouchDispatcher();
}
```
这样的话,如果我们上层的CCLayer是**后加入的游戏**中的话会先收到触摸事件,因为在优先级相同的条件下,越晚注册触摸事件,越先收到触摸消息~



2).只是这样还不够,在上层的CCLayer处理完触摸事件后,下层的按钮还会响应到消息,我们要做的是吞掉触摸消息:
```c++
bool CCBanPenetrateTouchLayer::ccTouchBegan( CCTouch* pTouch, CCEvent* pEvent )
{
	return true;//返回true表示吞噬触摸消息,不在往下传递
}
```
哈哈哈,现在试一下,是不是不会穿透下去了呢?



**3.在某些时刻,我们可能要禁止用户的任何输入,但游戏要正常运行,比如保卫萝卜?的倒计时界面:**

[![QQ截图20130705192657]({{BASE_PATH}}/images/5b7c482c533e4e4884f0253fdb6d9a951f8f8d6d.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130705192657.png)

1).简单说下思路,在需要禁止输入的时候,当前运行的CClayer addChild一个优先级为-128,吞噬触摸消息的CCLayer,在解除禁止的时候remove掉.

2).为此我封装了一个阻止穿透响应的类:CCBanPenetrateTouchLayer,继承自CCLayer:

头文件：
```c++
#ifndef _H_CCBANPENETRATETOUCHLAYER_H_
#define _H_CCBANPENETRATETOUCHLAYER_H_

#include "GameDefine.h"

class CCBanPenetrateTouchLayer
	: public cocos2d::CCLayer
{
public:
	CREATE_FUNC(CCBanPenetrateTouchLayer);

	CCBanPenetrateTouchLayer();
	~CCBanPenetrateTouchLayer();
public:
	virtual bool init();
	virtual bool ccTouchBegan(CCTouch* pTouch, CCEvent* pEvent);
	virtual void ccTouchMoved(CCTouch* pTouch, CCEvent* pEvent);
	virtual void ccTouchEnded(CCTouch* pTouch, CCEvent* pEvent);
	virtual void registerWithTouchDispatcher();
};

#endif
```
源文件：
```c++
#include "CCBanPenetrateTouchLayer.h"

CCBanPenetrateTouchLayer::CCBanPenetrateTouchLayer()
{

}

CCBanPenetrateTouchLayer::~CCBanPenetrateTouchLayer()
{

}

bool CCBanPenetrateTouchLayer::init()
{
	if (!CCLayer::init())
	{
		return false;
	}
	setTouchEnabled(true);

	return true;
}

bool CCBanPenetrateTouchLayer::ccTouchBegan( CCTouch* pTouch, CCEvent* pEvent )
{
	return true;
}

void CCBanPenetrateTouchLayer::ccTouchMoved( CCTouch* pTouch, CCEvent* pEvent )
{

}

void CCBanPenetrateTouchLayer::ccTouchEnded( CCTouch* pTouch, CCEvent* pEvent )
{

}

void CCBanPenetrateTouchLayer::registerWithTouchDispatcher()
{
	//使用-128和CCMenu优先级相同,并且吞掉事件true//
	CCDirector::sharedDirector()->getTouchDispatcher()->addTargetedDelegate(this, -128, true);
	CCLayer::registerWithTouchDispatcher();
}
```
3).使用:
```c++
bool CGameLayer:init()
{
	if (!CCLayer::init())
	{
		return false;
	}

        //禁止穿透
	CCBanPenetrateTouchLayer* pBanLayer=CCBanPenetrateTouchLayer::create();
	addChild(pBanLayer,kCCBTag_BanLayer,kCCBTag_BanLayer);

	//计时取消禁止穿透
	CCSprite*pCircle=CCSprite::create("count_down/circle.png");
	pCircle->runAction(
		CCSequence::create(
		CCRotateBy::create(3.0f,360*3),
		CCCallFuncN::create(this,callfuncN_selector(CGameLayer::onCountDownDone)),
		NULL));

        return true;
}
```
```c++
void CGameLayer::onCountDownDone(CCNode* pSprite)
{
	removeChild(pSprite,true);
	removeChildByTag(kCCBTag_BanLayer);
}
```


### ** 三.弹出式对话框**

**1.在游戏中,我们经常回用到弹出式对话框,比如暂停页面,胜利页面,确认取消对话框,MessageBox,细想一下,他们都有一个共同点,就是只能点击本层的按钮,下一层的是不能响应的,这样的话,我们就可以让他们都继承自:CCBanPenetrateTouchLayer即可!**

**问:CCBanPenetrateTouchLayer上的按钮能响应的到吗?为什么?**

答:还记得我们上面说的(在优先级相同的条件下,越晚注册触摸事件,越先收到触摸消息~)这样来看,CCBanPenetrateTouchLayer的创建肯定会先于它的child,所以呢，在优先级都是-128的情况下，它的child会先收到触摸消息！



**2.在上面的理论下，我在按下暂停按钮时，创建PauseLayer（继承自CCBanPenetrateTouchLayer的），addchild到当前layer上！在点击PauseLayer上的继续游戏按钮时调用removeFormParent！不要担心它的可行性，我的游戏就是这么做的~**

**问：我的layer是用cocosbuilder编辑的，可以用这套方案吗？**

答：完全可以，在你将一个ccbi和layer绑定时让你的layer不继承CCLaye而继承CCBanPenetrateTouchLayer的即可!

**问：如2所说，频繁的创建销毁PauseLayer会不会有效率问题呢？**

答：确实有这个可能，而且在Pauselayer非常大的时候会有延迟~这个问题非常好解决，在创建场景是提前创建好PauseLayer，调用下retain函数，在按下暂停按钮时只用addchild(m_pPauseLayer)即可，释放场景是别忘了调用release哦~



全文完



Ps：其实没有什么复杂的东西，只是分享一些我的经验~有什么疑问的话,请留言给我!以错误的话，欢迎指出~