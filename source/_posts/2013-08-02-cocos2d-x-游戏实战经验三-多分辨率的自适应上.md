title: "cocos2d-x 游戏实战经验(三) 多分辨率的自适应(上)"
id: 569
date: 2013-08-02 22:59:08
tags:
categories: [cocos2d-x,cocos2d-x游戏实战经验]
---

<address>**前言:网上的cocos2d-x教程多为知识点的讲解,但我们学习cocos2d-x的目的是为了什么?为了做出游戏来! cocos2d-x 游戏实战经验 系列文章将分享我在开发游戏过程中遇到的问题及解决方案!**</address>
<!--more-->


> 多分辨率的自适应应该是大家比较蛋疼的问题了吧,我之前去找工作面试的时候几乎每一家公司都会问我这个问题!那么什么是自适应呢?我认为就是使用1套或者2套(SD,HD)分辨率的资源自动去适应任何分辨率的设备,画面完整清晰!

### 一.前辈们的文章![QQ图片20130730113701]({{BASE_PATH}}/images/4d77f1a1f000ccc10d102a29f08924c3832a1cae.gif)



关于多分辨率的自适应,网上你会搜到一大篇的文章,但其实都是大家转来转去的文章,有好些转载的文章甚至没有说明出处,真的很无耻唉!尤其是使用百度搜索的时候,可能得翻好几页才能找到原文,我整理了下讲的好的就这么5篇文章:

**1.官网上的这篇:**[http://www.cocos2d-x.org/projects/cocos2d-x/wiki/Multi_resolution_support](http://www.cocos2d-x.org/projects/cocos2d-x/wiki/Multi_resolution_support "http://www.cocos2d-x.org/projects/cocos2d-x/wiki/Multi_resolution_support")

[![1024x768-480x320-800x480-ShowAll]({{BASE_PATH}}/images/dd33303e0e7da50006a51f6960f7b7e053956357.jpg)](http://blog.justbilt.com/wp-content/uploads/2013/07/1024x768-480x320-800x480-ShowAll.jpg)

英文文章,用心看的话应该都能看懂,讲的是cocos2d 2.x版本自带的3种适配方案,推荐看下!



**2.Alex Zhou的程序世界上的这篇:**[http://codingnow.cn/cocos2d-x/975.html](http://codingnow.cn/cocos2d-x/975.html "http://codingnow.cn/cocos2d-x/975.html")

[![20121204221454]({{BASE_PATH}}/images/2cc69c2640b0c3186961f9afbda08c44eb95a1cc.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/20121204221454.png)

这篇文章主要讲的也是cocos2d 2.x版本自带的3种适配方案,讲的还是蛮清晰,图文并茂还是很值得一看的!



**3.我是妖怪大大的这篇:**[http://dualface.github.io/blog/2012/08/17/cocos2d-x-2-dot-0-multi-resolution/](http://dualface.github.io/blog/2012/08/17/cocos2d-x-2-dot-0-multi-resolution/ "http://dualface.github.io/blog/2012/08/17/cocos2d-x-2-dot-0-multi-resolution/")

[![multires_ui01]({{BASE_PATH}}/images/b2281445091932aa131d452b72cc76dda84cc995.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/multires_ui01.png)

我是妖怪大大的这篇文章是主要讲的是多分辨率的原理,写的非常棒,我的很多想法都是从这篇文章中学习到的,就是源码中的实现我不是很赞同,毕竟现在手动去编写UI真的不多了!



**4.无间落叶大大的这篇:**[http://blog.leafsoar.com/archives/2013/05-10-19.html](http://blog.leafsoar.com/archives/2013/05-10-19.html "http://blog.leafsoar.com/archives/2013/05-10-19.html")

[![screen-resolution-3]({{BASE_PATH}}/images/f0148a4e25409840d55e788f64ed3df3e1c377c6.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/screen-resolution-3.png)

大家看到的最多的应该就是无间落叶大大的这篇文章了,泰然上曾经顶置了一段时间的,文章讲的十分详细,从理论知识到具体实现都有讲到,如果你能耐心看完的话,受益匪浅!



**5.还有K.C大大的讲cocosbuider的这篇:**[http://i.kimiazhu.info/?p=119](http://i.kimiazhu.info/?p=119 "http://i.kimiazhu.info/?p=119")

[![5-2]({{BASE_PATH}}/images/06423794f1fc5b6e7d25e9acc7302e386cf844af.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/5-2.png) [![5-3]({{BASE_PATH}}/images/d3e8d9da8214469156173ee3ab57855c1f99261f.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/5-3.png) [![5-4]({{BASE_PATH}}/images/5e7b20ffce693668c8f32ab8759b42bfe3a32d43.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/5-4.png)

网上讲ccb多分辨率的文章真的好少啊(几乎就这一篇文章),大部分文章就一句话:按照屏幕的四个角去设置位置或者按百分比去设置,也不知道他们到底试过了没有.......这篇文章算是稀品中的战斗机了!推荐大家看一下!



哈哈哈,前面唠叨了这么多,并不是说我的文章比他们好,鲁班门前岂容我等小辈班门弄斧?

![QQ图片20130730131039]({{BASE_PATH}}/images/d772303695c3bd86cd073f9e1083a451e5785af2.jpg)

小弟只是试着从一颗屌丝的角度出发,看能否写出一篇更通俗,全面一些的文章!如果有什么错误,欢迎前辈们不吝赐教!



### 二.宽高比与分辨率的知识[![QQ图片20130730131451]({{BASE_PATH}}/images/0a864b38cca31ecd05c9d0d41054418faaa085ac.gif)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ图片20130730131451.gif)



**分辨率:**一般来说我们是指设备横向和纵向的像素点的熟练,如:480x320,即横向有480个像素点,纵向有320个像素点!

**宽高比:**一般iphone我们是用分辨率的除它们的最大公约数得出的!如:480x320的最大公约数是160,这样它们的宽高比就是3:2! android的分辨率太多太过诡异,只能单独google了!

这样,我整理了下常用设备信息,如下:
<table width="497" border="0" cellspacing="0" cellpadding="0"><colgroup> <col width="224" /> <col width="142" /> <col width="131" /> </colgroup>
<tbody>
<tr>
<td width="224" height="18">设备</td>
<td width="142">分辨率</td>
<td width="131">宽高比</td>
</tr>
<tr>
<td height="18">iphone4/4s</td>
<td>960x640</td>
<td>3:2</td>
</tr>
<tr>
<td height="18">iphone5</td>
<td>1136x640</td>
<td>16:9</td>
</tr>
<tr>
<td height="18">ipad1/ipad2/ipadmini</td>
<td>1024x768</td>
<td>4:3</td>
</tr>
<tr>
<td height="18">ipad3/ipad4</td>
<td>2048x1536</td>
<td>4:3</td>
</tr>
<tr>
<td height="18">android 1</td>
<td>800x480</td>
<td>5:3</td>
</tr>
<tr>
<td height="18">android 2</td>
<td>854x480</td>
<td>16:9</td>
</tr>
<tr>
<td height="18">android 3</td>
<td>1280x720</td>
<td>16:9</td>
</tr>
<tr>
<td height="18">android 4</td>
<td>960x540</td>
<td>16:9</td>
</tr>
</tbody>
</table>

 表1

### 三.cocos2d-x 2.x版本自带的自适应方法分析[![QQ图片20130730131648]({{BASE_PATH}}/images/1f4a3872a9b1f2052a7977b10115f8da8b30de7a.gif)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ图片20130730131648.gif)

请看下图,这是在DesignResolutionSize为480x320,设备尺寸480x320正常效果下的HelloCpp:

[![QQ截图20130730134552]({{BASE_PATH}}/images/579f48e4c688a450ae8d49126d09610b96c7189e.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730134552.png)

**1.开启自适应**

大家打开HelloCpp工程的AppDelegate.cpp文件中的applicationDidFinishLaunching()函数,会发现下面这行代码:
```c++
// Set the design resolution
pEGLView->setDesignResolutionSize(designResolutionSize.width, designResolutionSize.height, kResolutionNoBorder);
```
这个函数是用来设置我们的设计尺寸和适配模式的:

**1).什么是设计尺寸(DesignResolutionSize)呢?**

不同的设备拥有不同的分辨率,我们不可能为每一个分辨率都去设计一种界面,准备一套素材,所以我们会有一个设计尺寸,然后将设计尺寸以某种规则投影到实际尺寸上去!更详细解释请移步上文中的第一篇官方的文章!

**2).适配方案(ResolutionPolicy)有哪些?**

**kResolutionExactFit** 强制拉伸到全屏幕显示,如果设计宽高比和实际宽高比不同时画面会变形扭曲!如下图:

[![QQ截图20130730134635]({{BASE_PATH}}/images/dba3ac84e3e0b8a8e98fb1dabc28e3b65cd2fa38.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730134635.png)
**kResolutionShowAll**按照宽和高的缩放系数的较小值去缩放画面,因为是等比缩放,所以不会失真,但是较大缩放系数的方向会出现黑边!如下图:

[![QQ截图20130730135304]({{BASE_PATH}}/images/e5bbf3d9723513b07824a30fc413b3a84f09d26d.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730135304.png)
**kResolutionNoBorder** 按照宽和高的缩放系数的较大值去缩放画面,这样也不会失真,但是较小缩放系数的方向因为放大的过多会导致超出屏幕边界!如下图:

![QQ截图20130730135323]({{BASE_PATH}}/images/86a1076578d4f3f2d041083299704c2acec9343d.png)

这三种适配策略是最简单的,如果必须在这3中方案中选择一个的话,我会选择kResolutionShowAll,它的效果相对来说是可以理解的,而且也不用做任何额外的工作!如果想要达到更好的效果的话呢,我们就需要费点心思了!



**2.默认自适应详解**

好吧,让我们来分析下上面的这几种适配方式,先看下面这行代码(CCEGLViewProtocol::setDesignResolutionSize函数):
m_fScaleX = (float)m_obScreenSize.width / m_obDesignResolutionSize.width;
m_fScaleY = (float)m_obScreenSize.height / m_obDesignResolutionSize.height;
从这个片段中可以看出cocos2d-x会用屏幕的实际尺寸(m_obScreenSize)除设计尺寸(m_obDesignResolutionSize)得到x(横)方向和y(纵)方向上的缩放系数!
```c++
// calculate the rect of viewport
float viewPortW = m_obDesignResolutionSize.width * m_fScaleX;
float viewPortH = m_obDesignResolutionSize.height * m_fScaleY;
```
这段代码是用来计算视口大小(可视区域外的东西是看不到的)的,不难得出如果m_fScaleX,m_fScaleY不做处理的话视口大小(viewPort)会等与屏幕的尺寸(m_obScreenSize).

**1).为什么kResolutionExactFit会出现变形失真呢?**

如果我们算出的m_fScaleX不等于m_fScaleY的话,将画面映射时会给宽高乘不同的缩放系数,这样就不是等比缩放了,自然会出现变形的问题!

**2).为什么kResolutionShowAll会有黑边呢?**
```c++
if (resolutionPolicy == kResolutionShowAll)
{
    m_fScaleX = m_fScaleY = MIN(m_fScaleX, m_fScaleY);
}
```
从代码中可以看到kResolutionShowAll选择了较小的缩放系数作为最终的缩放因子,这样m_fScaleX恒等于m_fScaleY,不会出现变形扭曲的问题,但是原本缩放系数较大的方向因为使用了较小的缩放系数导致算出的视口尺寸的宽或高(viewPortW or viewPortH)小于屏幕的尺寸的宽或高(m_obScreenSize.width or height),于是我们的画面无法映射到全屏幕,因此会出现黑边!

**3).为什么kResolutionNoBorder绘制的东西为什么会超出边界呢?**
```c++
if (resolutionPolicy == kResolutionShowAll)
{
    m_fScaleX = m_fScaleY = MAX(m_fScaleX, m_fScaleY);
}
```
从代码中可以看到kResolutionNoBorder选择了较大的缩放系数作为最终的缩放因子,所以较小缩放系数方向因为使用了较大的缩放系数从而导致算出的视口尺寸的宽或高(viewPortW or viewPortH)大于屏幕的尺寸的宽或高(m_obScreenSize.width or height),于是我们的画面的某个方向就映射到了屏幕外面,因此我们看到的效果就是画面上的有些东西一半在屏幕中,一半在屏幕外!



### 四.思路分析[![QQ图片20130730131728]({{BASE_PATH}}/images/1ba0cb1f1e7d5ff473b325f73af08452e241f952.gif)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ图片20130730131728.gif)

**1.去除黑边**

让我们看下下面这段代码(节选自2.14版本CCEGLViewProtocol::setDesignResolutionSize函数):
```c++
//这是新增加的以高度为基准的适配策略,将x方向取的缩放系数设置为y方向的缩放系数
if ( resolutionPolicy == kResolutionFixedHeight) {
	m_fScaleX = m_fScaleY;
	m_obDesignResolutionSize.width = ceilf(m_obScreenSize.width/m_fScaleX);
}
//这是新增加的以宽度为基准的适配策略,将y方向取的缩放系数设置为x方向的缩放系数
if ( resolutionPolicy == kResolutionFixedWidth) {
	m_fScaleY = m_fScaleX;
	m_obDesignResolutionSize.height = ceilf(m_obScreenSize.height/m_fScaleY);
}
```
细心的你一定会发现当resolutionPolicy == kResolutionFixedWidth或kResolutionFixedHeight时,视口大小会横等于屏幕尺寸(m_obScreenSize),这也正是去除黑边的办法(如果你的版本没有kResolutionFixedWidth和kResolutionFixedHeight的话,将相关的东西复制过去即可),这样我们就可以把原来是黑边废物利用了!

这里有两种方式:

**1).将黑边部分用图片填充,那里仍然不能有触摸事件,这样游戏内容的可用空间并没有增加,只是美观了些许!**比如MT:

[![005]({{BASE_PATH}}/images/b1c206d2b62dc4f96e1e023c09e61ec0de6af1e5.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/0051.png)

**2).显示更多的游戏内容,一般用在原本游戏内容就大于视口的游戏中!**比如COC类游戏:

[![20130722103545_1337]({{BASE_PATH}}/images/ed479502226a8e332a4c68a4e5c5c60c1a622208.jpg)](http://blog.justbilt.com/wp-content/uploads/2013/07/20130722103545_1337.jpg)

这两种模式,一种是固定设计时的高,一种是固定设计时的宽,如果你的游戏是横屏的,我们肯定希望无用区域在左右两边,即固定高度(kResolutionFixedHeight),而不是上下,因为上下本来就很小!竖屏游戏则反之!



**2.不同的东西有不同的适配策略**

**1).背景层**

一般来说我们并不十分关心背景层上的东西,我们只希望它能够平铺整个画面

1.  因此我们可以准备一张很大的背景图,足以覆盖任何设备的屏幕!
2.  准备几张用来填充多余区域的图片,贴在多余区域即可!
3.  考虑使用CCLayerColor,CCLayerGradient作为背景,这样会自动填充满整个窗口的!
我选择的是1的方法,这样与背景的融合图更高(点击查看大图):

[![background]({{BASE_PATH}}/images/a746748792116d13d6c32618249ec41b8aa4c46e.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/background.png)

**2).游戏核心内容**

这里才是我们要关心的,这里一般会有两种做法:

1.  按照实际的屏幕尺寸的百分比去设置每个元素的位置,这样做的代价非常大!
2.  如果你的游戏内容就大于屏幕尺寸的话,恭喜你,你不用做任何操作,只是玩家看到的东西更多罢了!
3.  还是按照正常的方式去设置元素位置,只不过将所有的元素加入到一个节点上,最后将这个节点设置在屏幕中心位置!
我采用的是3的方法来的,所有的元素都加入到CGameLaye身上:

[![QQ截图20130730120542]({{BASE_PATH}}/images/0e4ced915f3cf322683623dac6b47be1af87aa3f.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730120542.png)

**3).UI布局**

1.  一种做法是按照"米"这样9个基准点去设置相对位置(上,右上,右,右下,下,左下,左,左上,中心)!
2.  按照屏幕的%百分比去设置位置.
我采用的是第二种做法,因为我的UI是在cocosbuilder中编辑的,大家可以对比下面两张图:

[![QQ截图20130730124918]({{BASE_PATH}}/images/65c61ba4a245a1a26071acb7a60c17e2b873e1d4.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730124918.png)

[![QQ截图20130730125001]({{BASE_PATH}}/images/30da72dd00b014e4d929cb32b1b3b7a0d51708e9.png)](http://blog.justbilt.com/wp-content/uploads/2013/07/QQ截图20130730125001.png)

在分辨率差距很大的情况下,UI在两张图片上的相对位置是不变的!



(上文完,下文将详细讲述如何实现)