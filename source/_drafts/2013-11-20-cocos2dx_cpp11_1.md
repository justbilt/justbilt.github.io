title: C++ 11 在cocos2d-x 3.0中的应用(上)
date: 2013-11-20 11:39:24
tags: [c++11,cocos2d-x]
categories: [c++]
---


## **前言**

不知道大家有没有看过这个视屏,[王哲、张晓龙《Cocos2d的多维展开》][1],推荐大家看一下,真心感觉cocos2dx越来越牛逼了,视频中提到3.0的一大改进就是支持c++11,虽然没有细讲,但是列出了一些关键字,如下图:

![][2]

从图上可以看到有这么几个新的东西,分别是:

```c++
lambdas
auto
ullptr
final
override
std::function
std::thread
range loop
enum class
```


下面我们由易到难的来看看他们分别是什么作用,用法是什么!


## **1.nullptr**

用一句话来概括就是:

**C++ 11中引入的nullptr主要用途：可以解决某些函数重载时的二义性问题!**

在c++11之前,空指针的关键字NULL和0是等价的,因此以下情况都是可以编译通过:
```c++
char* pc1=0;
char* pc2=NULL;
int na=NULL;
```

但是这样很容易引起歧义,比如:
```c++
void fun(char c){}//函数重载1
void fun(char* pc){}//函数重载2
int main()
{
	fun(NULL);//调用重载2
	return 0;
}
```
虽然我们非常明确的要调用参数为指针的重载函数,但是编译器还是非常的迷惑,导致**编译错误**!

但是当你抛弃NULL而使用nullptr时,这一切将迎刃而解,nullptr与0有本质上的区别!请看:
```c++
int a=nullptr; //编译错误,类型不匹配
fun(nullptr);//正确调用重载2
```



## **2.auto**

引用大神的一句话:

**C++ 11中引入的auto主要有两种用途：自动类型推断和返回值占位。**

什么意思呢,请看下面示例:

![][3]

另外,如下的写法是**错误**的,无法编译通过:
```c++
auto g;	//无法推断出g的类型
```

哈哈,是挺简单的吧!如果说上面的写法是可有可无的话,那下面的这个写法可真是十分的便利:

```c
std::map<int,int> mapintint;

std::map<int,int>::iterator it1=mapintint.find(5);//这是最普通的写法

typedef std::map<int,int>::iterator mapintintIt;
mapintintIt it2=mapintint.find(5);//这是稍微聪明一些的写法

auto it3=mapintint.find(5);//哈哈,在c++11中可以这样做,是不是很爽

mapintint.insert(std::map<int,int>::value_type(6,6));//但是这个貌似没有办法用auto来用
```
auto的用法十分简单,所以也没有什么可说的!


## **3.final**
final比较简单,请看:

1.被声明为final的class无法被继承:
```c++
class MyClass1 final
{
};
class MyClass2 : public MyClass1 //错误,MyClass1已被声明为final,无法继承
{
};
```

2.被声明为final的函数无法被**重写**:
```c++
class MyClass1
{
	virtual void fun()final;
};

class MyClass2 : public MyClass1 
{
	virtual void fun();//错误,fun已被声明为final,无法重写
};
```


## **4.override显式虚函数重载**
override相对也比较简单,c++11的引入主要是防止虚函数重写的误使用,如果函数的末尾声明了override,则其父类必须要有能重写的对象,例如:
```c++
class MyClass1
{
	virtual void fun();
	void fun2();
	virtual void fun3();
	virtual void fun4();
};

class MyClass2 : public MyClass1 
{
	void fun()override;//正确
	void fun2()override;//错误,MyClass1的fun2不是虚函数
	void fun3(float f)override;//错误,MyClass1的fun3无参数
	bool fun4()override;//错误,MyClass1的fun4返回值不同
};
```

## **5.enum class强类型枚举**
在c++11之前,枚举是被当做整数处理的,这样是不安全的,c++11引入enum class来声明安全类型的枚举,这时枚举被当做自定义类型处理的,主要体现在**判断**和**赋值**上,请看:

```c++
enum class COLOR1{RED,BLUE,BLACK,};
enum class COLOR2{RED,BLUE,BLACK,};

COLOR1 rc=RED;			//错误,强类型枚举必须指明出处
COLOR1 rc=COLOR::RED;	//正确

COLOR1 rc=(COLOR1)5;	//正确,可惜还是没有加入范围的判断:-(
if (rc==5){}			//错误

if (rc==COLOR2::RED){}	//错误
```


## **6.Range-based for loops**

这个中文叫什么还真不好说,但它带来的便利确实十分大的,请看:
![][4]
这样的写法对于stl的容器类(map,vector,list...)也同样适用:
![][5]
是不是非常的方便,请注意下面的写法:

```c++
	//这个也是新写法,作用同上
	for each (auto i in arrint)
	{
		cout<<i<<endl;
	}
	//这样的写法是错误的,原因是int* 类型没有重载begin函数
	int* p = new int [2];
	p[0] = 1;
	p[1] = 2;
	for (auto x : p) 
	{
		cout << x << endl;
	}
```



**本文参考了以下几篇文章,大家有兴趣可以看一下,多谢作者:**

[C++11学习笔记（4） —— new for loops][6]

[C++11新特性：Range-based for loops][7]

[C++ 11语法甜点1][8]

[C++ 11语法甜点1][9]






**(上文完)**



[1]:http://v.youku.com/v_show/id_XNjMwNzIyNDU2.html
[2]:http://ww1.sinaimg.cn/large/7f870d23jw1earc0tc668j218g0p0n0n.jpg
[3]:http://ww1.sinaimg.cn/large/7f870d23jw1earg3wzqvnj20hy06st9a.jpg
[4]:http://ww3.sinaimg.cn/large/7f870d23jw1easep6hadnj20ot0640ta.jpg
[5]:http://ww3.sinaimg.cn/large/7f870d23jw1easfbb4xxyj20sk06nwf8.jpg
[6]:http://blog.csdn.net/fire_lord/article/details/8539115
[7]:http://blog.csdn.net/srzhz/article/details/7952723
[8]:http://www.cnblogs.com/hujian/archive/2012/02/20/2358853.html
[9]:http://www.cnblogs.com/hujian/archive/2012/12/07/2807941.html