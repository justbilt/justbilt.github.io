title: "cocos2d-x 获取系统时间的问题"
id: 540
date: 2013-07-23 15:59:46
tags:
categories: [cocos2d-x]
---

### 一.预备知识

在看这篇文章之前,大家先可以看下这篇文章:[http://developer.51cto.com/art/201002/182941.htm][1] (C++获得系统时间不同方案介绍)
<!--more-->


### 二.如何获取系统时间.

**1.获取日历时间:**
```c++
time_t tt;
//返回自从 Unix 新纪元（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数。
time(&tt);
```
** 2.获取之后转化为年月日时间:**
```c++
struct tm {
        int tm_sec;     /*秒数 seconds after the minute - [0,59] */
        int tm_min;     /*分钟数 minutes after the hour - [0,59] */
        int tm_hour;    /*小时 hours since midnight - [0,23] */
        int tm_mday;    /*月份中的第几日 day of the month - [1,31] */
        int tm_mon;     /*年份中的第几个月，从 0 开始表示一月 months since January - [0,11] */
        int tm_year;    /*年份，从 1900 开始 years since 1900 */
        int tm_wday;    /*星期中的第几天 days since Sunday - [0,6] */
        int tm_yday;    /*一年中的第几天 days since January 1 - [0,365] */
        int tm_isdst;   /*夏令时当前是否生效 daylight savings time flag */
        };
```
** 3.打印出当前是一年中的第几天:**
```c++
struct tm *p;
p = localtime(&tt);
CCLog("%d",p->tm_yday);
```

### **三.注意事项:**

**1.对于下面的代码:**
```c++
time_t tt;
time(&tt);
struct tm *p1;
p1 = localtime(&tt);

time(&tt);
struct tm *p2;
p2 = localtime(&tt);

if (p1->tm_sec!=p2->tm_sec)
{
	//do something...
}
```
大家觉得能否达到效果呢?(假设两次调用localtime的间隔很长)

答案是否定的:因为p1和p2指向了相同的地址,所以条件永远不成立!为什么呢?因为我们没有在调用localtime之前给p1和p2分配空间(栈,堆),而是用一个指针去接函数的返回值,这样的话只有两种可能:

*   每次函数内部都会new一个tm的对象,返回,这样外部必须手动释放才不至于内存泄露!
*   每次函数都返回同一块内存的指针,这样后一次的调用会覆盖前一次的结果!
所以我们必须自己去保存结果:
```c++
int pre_tm_sec=p1->tm_sec;
```


**2.不同平台的差异:**

time_t在linux上的定义:
```c++
#ifndef __TIME_T
#define __TIME_T     /* 避免重复定义 time_t */
typedef long     time_t;    /* 时间值time_t 为长整型的别名*/
#endif
```
有此可见time_t就是long,只占4个字节!



而在windows上:
```c++
typedef __int64 __time64_t;     /* 64-bit time value */
typedef __time64_t time_t;      /* time value */
```
尼玛?坑爹的windows,这样time_t就是int64,占8个字节!



我曾经用long记下time_t类型的数据写入到存档中,结果就悲剧了,内存越界,死的心都有了!












[1]: http://developer.51cto.com/art/201002/182941.htm